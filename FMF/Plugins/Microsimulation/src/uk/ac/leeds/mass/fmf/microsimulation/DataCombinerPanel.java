/*
 *   The Flexible Modelling Framework is a Social Science application for 
 *   synthesising individual level populations. 
 *   Copyright (C) 2013  Kirk Harland
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *   Contact email: Andy Evans: a.j.evans@leeds.ac.uk
 */
package uk.ac.leeds.mass.fmf.microsimulation;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import uk.ac.leeds.mass.fmf.shared_objects.*;
import uk.ac.leeds.mass.fmf.fit_statistics.*;




/**
 * This code joins synthetic populations (Area and microdata ID) back to the microdata so you get one file with everything.
 * This is the user interface element. It is initialised by DataCombiner, and initialises DataCombinerProcess.
 * Here "synthetic population is the file generated by the microsimulation, which contains area and individual IDs.
 * "Microdata" is the file containing individuals, tied to the sythetic population by the individual IDs unique to each individual and 
 * present in both files.
 * @version 1.0
 * @author <A href="http://www.geog.leeds.ac.uk/people/a.evans/">Andy Evans</A>
 */
public class DataCombinerPanel extends JPanel implements ActionListener {


	/**
	* GUI label for synthetic population.
	*/
    private javax.swing.JLabel jLabel1;
	
	/**
	* GUI label for the microdata.
	*/
    private javax.swing.JLabel jLabel2;
	
	/**
	* GUI label for the individual IDs.
	*/
    private javax.swing.JLabel jLabel3;
	
	/**
	* Drag box for the synthetic population.
	*/
    private javax.swing.JTextField popTableField;
	
	/**
	* Drag box for the microdata.
	*/
    private javax.swing.JTextField microDataTableField;
	
	/**
	* Drag box for the individual IDs.
	*/
    private javax.swing.JTextField personIDField;
	
	/**
	* FMFTable containing the synthetic population.
	*/
	private FMFTable popTable = null;
	
	/**
	* FMFTable containing the microdata.
	*/
    private FMFTable mdTable = null;
	
	/**
	* Structure for accessing other parts of the application.
	*/
    private IApplicationInformation ai = null;
	
	/**
	* RDS (~directory) containing the synthetic population FMFTable.
	*/
    private RegisteredDataSource popRDS = null;
	
	/**
	* RDS (~directory) containing the microdata FMFTable.
	*/
	private RegisteredDataSource mdRDS = null;


   
    /** 
	 * Creates new DataCombinerPanel.
     * @param ai current ApplicationInformation object
     */
    public DataCombinerPanel(IApplicationInformation ai) {
        
		this.ai = ai;
        initComponents();
        customiseComponents();
    }

	
	
	
    /** This method is called from within the constructor to
     * initialize the form.
     */
    @SuppressWarnings("unchecked")
    private void initComponents() {

	
		// Partly automaticly generated code, but I messed with it manually.
		// GUI text also drawn in paint.
		
		// Sets up GUI.
		
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
	
        popTableField = new javax.swing.JTextField();
        microDataTableField = new javax.swing.JTextField();
        personIDField = new javax.swing.JTextField();

		Button runButton = new Button("Run");
		runButton.setMaximumSize(new java.awt.Dimension(75, 30));
		runButton.addActionListener(this);
        setPreferredSize(new java.awt.Dimension(351, 245));
        setRequestFocusEnabled(false);

		 
        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel1.setText("Synthetic join:");

		popTableField.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(153, 153, 153)));
		popTableField.setEditable(false);
		popTableField.setText("<<not set>>");
        popTableField.setToolTipText("Synthesised population table generated by microsimulation.");
		
        jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel2.setText("Microdata:");

        microDataTableField.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(153, 153, 153)));
		microDataTableField.setEditable(false);
        microDataTableField.setText("<<not set>>");
        microDataTableField.setToolTipText("The microdata table.");
		
		
        jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel3.setText("Microdata ID column:");

        personIDField.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(153, 153, 153)));
		personIDField.setEditable(false);
        personIDField.setText("<<not set>>");
        personIDField.setToolTipText("Column in microdata containing person ID.");
        

        

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabel2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 17, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(popTableField, javax.swing.GroupLayout.DEFAULT_SIZE, 202, Short.MAX_VALUE)
                    .addComponent(microDataTableField, javax.swing.GroupLayout.PREFERRED_SIZE, 189, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(personIDField, javax.swing.GroupLayout.PREFERRED_SIZE, 189, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
			.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 17, Short.MAX_VALUE)
			
			)
			.addGroup(layout.createSequentialGroup()
			.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 17, Short.MAX_VALUE)
			.addComponent(runButton)
			.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 17, Short.MAX_VALUE))
        );

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {microDataTableField, popTableField, personIDField});

        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(popTableField, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(microDataTableField, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(personIDField, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
				.addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
				.addComponent(runButton))
				.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
			)
        );

		
		
	}



    
	/**
	* Method for getting synthetic population RDS -- left for later possible error catching.
	* @return synthetic population RDS
	*/
    private RegisteredDataSource getPopRDS(){
        return popRDS;
    }



	
	/**
	* Method for getting microdata RDS -- left for later possible error catching.
	* @return microdata RDS
	*/	
	private RegisteredDataSource getMdRDS(){
        return mdRDS;
    }
	
	
	
	
	/**
	* Method for getting synthetic population FMFTable -- left for later possible error catching.
	* @return population FMFTable
	*/
	private FMFTable getPopTable(){
        return popTable;
    }

	
	
	
	/**
	* Method for getting microdata FMFTable -- left for later possible error catching.
	* @return microdata FMFTable
	*/
	private FMFTable getMdTable(){
        return mdTable;
    }

	
	
	
	/**
	* Method for getting microdata ID column field.
	* @return microdata ID column field
	*/
	private String getPersonIDField(){
        if (personIDField.getText().equals("<<not set>>") ){
            return "";
        }else{
            return personIDField.getText();
        }
    }
	
	
	
	
	/**
	* Sets up drag and drop.
	*/
    private void customiseComponents(){

	
		
		// Synthetic population box on GUI.
        this.popTableField.setTransferHandler(new DataSourceHandler(){

            @Override
            public boolean shouldImport(TreeCellInfo t) {
                if ( t.getType() == TreeCellInfo.TABLE | t.getType() == TreeCellInfo.TABLE_ALTERED |
                            t.getType() == TreeCellInfo.TABLE_CACHED ){
                    return true;
                }
                return false;
            }

            @Override
            public void doAction(TreeCellInfo t) {
                popRDS = t.getRDS();
                popTable = popRDS.getTable(t.toString());
				popTable.loadData(ai, null);
                popTableField.setText(t.toString());
            }

        });

		
		// Microdata box on GUI.
		this.microDataTableField.setTransferHandler(new DataSourceHandler(){

            @Override
            public boolean shouldImport(TreeCellInfo t) {
                if ( t.getType() == TreeCellInfo.TABLE | t.getType() == TreeCellInfo.TABLE_ALTERED |
                            t.getType() == TreeCellInfo.TABLE_CACHED ){
                    return true;
                }
                return false;
            }

            @Override
            public void doAction(TreeCellInfo t) {
                mdRDS = t.getRDS();
                mdTable = mdRDS.getTable(t.toString());
				mdTable.loadData(ai, null);
                microDataTableField.setText(t.toString());

            }

        });
		
		
		
		// Microdata ID box on GUI.
        this.personIDField.setTransferHandler(new DataSourceHandler(){

            @Override
            public boolean shouldImport(TreeCellInfo t) {
                if ( (t.getType() == TreeCellInfo.NUMERIC_FIELD | t.getType() == TreeCellInfo.TEXT_FIELD) &&
                            ( mdTable != null && mdTable.fieldExists(t.toString()) ) ){
                    return true;
                }
                return false;
            }

            @Override
            public void doAction(TreeCellInfo t) {
                personIDField.setText( t.toString() );
            }

        });

        
    }


	
	
	
    /** 
	 * Only here as a minimal user interface element. Adds text.
     * @param g ToolPanel graphics context.
     */	
	public void paintComponent(Graphics g) {
            super.paintComponent(g);
			g.drawString("This takes a results table of Zone and Person IDs (Synthesised ", 10,160);
			g.drawString("population table) and joins it with an appropriate microdata set", 10,175);
			g.drawString("to create a table containing a synthetic population with each", 10,190);
			g.drawString("person allocated a zone ID. If any columns have the same name", 10,205);
			g.drawString("only one will be filled, the others will be zeroed.", 10,220);
			g.drawString("NB: This is a long process: a million records could take 12hrs+.", 10,235);
	}
	
	
	
	
	/**
	* Generates a DataCombinerProcess.
	* @param ae User has pushed the run button.
	*/
	public void actionPerformed(ActionEvent ae) {
	
		ai.getProcessManager().addProcess(new DataCombinerProcess(ai,  getPopTable(), getMdTable(), getPersonIDField()));
	
	}
	
	
	
      
}

   



    
    



